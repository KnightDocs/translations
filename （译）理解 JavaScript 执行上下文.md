# （译）理解 JavaScript 执行上下文

## 它如何影响作用域和 this

在JavaScript中，你写一些代码，之后JS引擎解析它们。为了理解这背后到底发生了什么，你就需要有一个基础的了解。在这篇文章中，我们将会把重点放在：作用域、上下文以及执行上下文。

### 作用域 ( Scope )

简单来说，scope 的意思贴近于变量的可见性 ( **visibility of variables** )，通常情况下，作用域和上下文 ( **context** ) 会互相混淆，但实际上它们是完全不同的。有了作用域，你可以控制变量的可得性 ( **accessibility of your variables** )。在全局作用域 ( global scope ) 中被创建的变量可以被其他任何作用域获得（译者说：也就是访问），然而局部变量 ( local variables ) 却只能被它自己所在的函数访问。

### 上下文 ( Context )

上下文就是 **this** 的值。它也会指向一个对象，这个对象拥有对应的函数或者方法。( **It also refers to the object that a function/method belongs to.** )

不同的函数调用方式会产生不同的上下文 ( this 的值 )。在全局作用域中，this 的值总是 window 对象。（译者说：也就是指向 window）

```javascript
console.log(this); // window
```

如果函数是一个方法（译者说：也就是说有一个对象，它有一个属性的值是函数，那么这个属性就叫对象的方法。），this 的值就是该方法属于的对象。当然，this 关键字不是那样简单地去理解的。在这篇文章中，我不打算更加详细地去深入this关键字是如何运作的，只是强调它与作用域，上下文，执行上下文的关系。理解 this 的工作原理是 JavaScript 中最困难也是最重要的主题之一。幸运的是，这里有很多资源。如果你不是太清楚，我建议你可以看一看这些资源。

* [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)
* [JavaScript.info](https://javascript.info/object-methods)
* [Mastering The JavaScript This Keyword](https://www.thecodingdelight.com/javascript-this/)

this 取决于函数如何被调用以及在哪里被调用，而不是在哪里被声明。每次从不同的执行上下文被调用，那么它的意义也会发生改变。为什么是执行上下文呢？因为 **this 本质**上指向函数的当前执行上下文 ( *function’s current execution context* )。

### 执行上下文 ( Execution Context )

执行上下文是你需要去理解的，这样你就能进一步理解 JavaScript 代码是如何运作的。首先，这是一个非常抽象的概念，它代表 JavaScript 运行的时候产生的**环境**。在这个环境里到底发生了什么呢？主要有两件事。第一，逐行分析代码；第二，将变量和函数存储到内存中。简单来说，它有两个类型：

* 全局执行上下文 ( Global Execution Context )
* 局部执行上下文 ( Local Execution Context )

在写JS代码时，首先被创建的就是全局执行上下文。它是**默认**的上下文。

局部执行上下文是在调用函数时被创建的，而不是在它被声明时创建。（译者说：一个函数只是写在js文件里，却没有去调用，那么就没有所谓的局部上下文出现。）

由于这很抽象，我会用这幅图来讲解。

![image-20210412121203791](https://miro.medium.com/max/819/1*CuL8xsqLb1GhpuHgmDKk0A.png)

现在看着这幅图，当JS引擎开始读取你的代码时，它就会创建一个全局上下文。然后逐行分析并把你的变量 ( variables ) 添加到内存 ( memory ) 中。

假设你定义了这样一个函数：

```javascript
function adding(num) {
  let number=num+2;
  return number;
}
```

然后你调用它。

```javascript
adding(3);
```

当引擎正在分析代码时，如果它需要执行这个函数，那么一个新的执行上下文将会被创建出来。于是在这个新的执行上下文中，引擎就会帮你逐行分析代码，```number```这个变量会被添加到局部内存中，然后继续分析后面的代码。在这之后，引擎就会返回到之前的执行上下文。

使用 **return** 关键字可以退出局部执行上下文并在先前的执行上下文中继续进行解析。图中的箭头就表示这个循环的过程。每当函数被调用时，这个过程就会再一次发生。每一次调用都会产生**不同的**局部执行上下文。

简单总结一下：

1. 全局上下文一开始就会被创建。
2. 一个函数不管什么时候被调用，都会创建一个新的局部执行上下文。
3. JS引擎会逐行分析全局上下文中的代码。
4. 当引擎遇到一个函数调用，那么它会进入一个局部执行上下文，并在其中继续解析代码。
5. 当它处理完函数的执行时，它就会离开局部执行上下文，返回到先前那个执行上下文中。

这给我们带来另一个重要的概念。引擎是如何知道要进入或退出哪一个执行上下文的呢？这个答案是调用栈 ( **Call Stack** )。

调用栈是JS引擎追踪执行上下文的一个机制，它能够知道执行上下文哪一个要进入，哪一个要退出或者哪一个要返回。在一个栈的底部就是全局执行上下文。当一个函数被调用，那么一个新的局部执行上下文就会被添加 ( push ) 到调用栈的顶部。一旦它完成解析，它就会被移除 ( pop )。让我用一副图来解释这个概念：

![image-20210412123759831](https://miro.medium.com/max/1161/1*lcTk7Ev0gp_H3Krup6G1EA.png)

那么这里发生了什么呢？

1. 引擎开始分析代码，全局执行上下文自动添加到调用栈。
2. Function1 被执行，一个局部执行上下文被添加到全局执行上下文的上方。在Function1中，引擎会继续分析其中的代码。
3. 在 Function1 中遇到 Function2 的调用，于是一个新的局部执行上下文被创建并被添加到调用栈的顶部。在 Function2 执行完毕后，它就从调用栈中被移除了。
4. Function1 执行完毕后，它同样也从调用栈中被移除出去。
5. 最后，它返回到了全局执行上下文。引擎继续分析并执行所有代码。

### 执行上下文的阶段 ( Phases of Execution Context )

纵观全文，你可能会很想知道这个执行上下文到底是如何被创建的。尽管这很抽象，但是它实际上就是一个过程，引擎会按照一些步骤来执行这个过程。

基本上有两个阶段：

1. 创建阶段 ( Creation Phase )
2. 执行阶段 ( Execution Phase )

在**创建阶段**，引擎首先创建了**活动对象** (  *Activation object* ) 或者**变量对象** ( *Variable object* )。它由变量 ( variables )、参数 ( arguments )、函数声明 ( function declarations ) 组成。在这个阶段，他们被分配了一个值：```undefined``` 。

参数这个属性是一个拥有长度 ( length ) 属性的对象（也就是类数组），传递给函数调用的所有参数都存储在这个对象中。

在这之后，引擎创建了作用域链 ( scope chain )。每一个执行上下文都知道这个作用域链。它有一个外部作用域的引用，通过它就可以访问外部作用域，一直到全局作用域。于是，在引擎搜索一个变量（不管这个变量是否存在）时，就会从当前作用域开始查找，一直可以找到全局作用域。作用域链就是一个对象的列表，它由自己的变量对象和他父级的变量对象组成。

最后， this 的值就被确定下来了。在全局执行上下文中，它的值是 ```window``` / ```global```对象，然而在每次函数被调用时，它的值可能就会发生变化。

在**执行阶段**，变量被赋值，引擎执行代码。                                                                                                                                                                                                                                                

**2021.4.12 Translated by Knight**