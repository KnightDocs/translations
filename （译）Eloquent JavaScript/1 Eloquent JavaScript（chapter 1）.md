Eloquent JavaScript 

3rd edition (2018)

# 第一章	值、类型、操作符

> 机器的背后是程序的运转，它可以轻松地膨胀和收缩。电子以非常和谐的方式散射并重组。显示器上的表格只是水面之涟漪，其中的精华藏在暗处。
>
> —— Master Yuan-Ma, The Book of Programming

在计算机世界中，只有数据，你可以读取数据，修改数据，创建新的数据。所有这些数据都存储为较长的位（bits 比特）序列，因此从根本上是相似的。

位（Bits 比特）是任何含有两个值的东西，通常用 0 和 1 来描述。在计算机内部，它们以高电荷或低电荷、强信号或弱信号、CD表面的光亮点或暗淡点等形式存在，任何离散信息都可以简化为零和一的序列，从而以位表示。

举个例子，我们能够用位来表达数字 13 。它的原理与十进制数字相同，但你只有2个不同的数位，而不是10个，从右往左每次增加 2 就会进一位 。这里就是组成数字 13 的位：

```
  0   0   0   0   1   1   0   1
128  64  32  16   8   4   2   1
```

也就是二进制数：00001101，它的非零数字分别表示8、4、1，加到一起就是 13。

## 值 （Values）

想象一下如海洋般的比特数。一台典型的现代计算机的运行内存有超过300亿位，硬盘或等效存储设备的容量往往要高出几个数量级。为了能够处理如此多的比特而不丢失，我们必须将它们分割成代表信息片段的块（chunks）。在JS中，这些块被称为值（*values*）。虽然所有值都是由比特组成的，但是它们扮演着不同的角色。每一个值都有各自的类型。一些值是数字，一些值是文本的片段，一些值是函数等等。

为了创建一个值，你只要呼唤它的名字即可。这就很方便，所以你不必为你的值去收集建筑材料，当然也不用花钱咯。你只要呼唤它，嗖地一声就会出现在你的面前。当然，它们并不是凭空创造出来的，每一个值都必须存在某一个地方，而且如果你突然想要用很庞大的数据，那就可能内存不足，结果就是宕机。幸运的是，只有你同时要用那么多数据时才会出现这种问题。一旦你不用某个值的时候，它就会消失，这样就能回收利用。

这一章介绍JavaScript程序中最基本的东西，简单的值类型以及用来可以操作这些值的操作符。

## 数字（Numbers）

数字类型的值自然就是数字了。在JS程序中，它们可以像这样写：

```
13
```

在程序中使用它的话，就会导致13这个数字对应的比特模式出现在计算机的内存中。

JavaScript 使用64位来存储某个单一的数字的值。但是它表示的数字仍然是有限的，n 个十进制数，你能表示 10^N^ 种数字。相似的，64 位的二进制数字，可以表示 2^64^ 种不同的数字，大概是18后面跟18个零，也很多。

过去，计算机内存很小，人们倾向于使用8或16位来表示数字，但是这么小的内存就很容易溢出，最终就会得到一个不合适的结果。今天，即使是放在你口袋里的计算机也有足够的内存，所以你可以自由地使用64位的数据了，除非处理那些天文数字时才有溢出的可能。

不过，并不是 2^64^ 的所有数字都适合于JS的数字，那些位也保存负数，所以有一个位是表示数字的符号的。而且更大的问题是，非整数也得表示出来，为了达到这个目的，一些位就用来存储小数点的位置。最后，可以存储的实际最大整数在9兆个（15个零）的范围内，非常棒。

分数（Fractional numbers）通过一个点来表示。

```
9.81
```

对于非常大或非常小的数字，你可以用科学计数法，也就是添加 e（*exponent*），例如 ：

```
2.998e8
```

2.998 × 10^8^ = 299,800,000

小于9兆（15个零）这个数量级的整数（whole numbers, also called *integers*）计算可以保证精度的准确。可惜，分数的计算通常不是这样，就像 π （pi）不能用十进制精确得表达一样，我们在只用 64 位去存储数字时，它们也会丢失一些精度。这很遗憾，但是这些问题只会发生在特定的情况下。重要的一点是能够意识到，把分数当做近似值而非精确的值。

## 算术运算（Arithmetic）

利用数字主要做的事情就是算术运算了，比如加法（addition ）和乘法（multiplication ）就是取两个数字的值然后根据它们产生一个新的数字。在JS中，它们就像这样：

```
100 + 4 * 11
```

```+```和```*```被称为操作符（运算符）。第一个表示加法，第二个表示乘法。将运算符放在两个值之间，就能用它来产生一个新值了。

但是例子中是表示“100+4，然后再用它的结果去乘以11”吗？正如你可能猜到的，乘法会先发生。但是在数学里，你可以通过加上小括号（parentheses）来让加法先执行。

```
(100 + 4) * 11
```

对于减法（subtraction），用```-```操作符，除法（division ）用```/```操作符。当运算符一起出现而没有括号时，它们的应用顺序由运算符的优先级（*precedence* ）确定，这个例子就说明乘法在加法之前。```/```运算符的优先级与```*```相同，```+```和```-```也是这样。当有多个运算符的优先级相同时，如：1 - 2 + 1，就从左到右依次运算：(1 - 2 ) + 1

不必担心这些优先级的规则，搞不清的时候，加个小括号就行了。

还有一个算术运算符，你可能没想到。```%```表示余数（*remainder* ）运算符。X％Y是X除以Y的余数。举个例子，314%100得到14，144%12得到0。余数运算符和乘法、除法的优先级一样。你也会经常看到这个运算符被称为模（*modulo*）。

## 特殊的数字（Special numbers）

在JS中，有三个特殊的值被当做是数字，但它不像正常的数字。

头两个是```Infinity```和```-Infinity```，第一个代表正无穷，第二个代表负无穷。```Infinity - 1```仍然是```Infinity```，以此类推。不过，不要相信基于无穷的计算，这听起来就不是数学，它很快就会导致下一个特殊的数字：```NaN```。

```NaN```表示 "not a number"（不是一个数字），尽管它是一个数字类型的值。你什么时候会得到这个值呢，比如，计算 0/0，Infinity - Infinity，或者不产生有意义结果的任何其他数字的操作。

## 字符串 （Strings）

下一个基本的数据类型是字符串（string）。字符串被用来代表文本，它们是用引号括起来的。

```javascript
`Down on the sea`
"Lie on the ocean"
'Float on the ocean'
```

你可以使用单引号、双引号或反引号来标记字符串，只要字符串开头和结尾的引号都能匹配即可。

几乎任何东西都可以放在引号之间，JavaScript会从中生成一个字符串值。但是有一些字符（characters）就不是那样了，你能够想象在引号（quotes）之间加上引号是何等困难。仅当字符串用反引号（`）引起来时，才可以包含换行符（按Enter时得到的字符）而不会转义。为了使这样的字符包含在字符串中，就要使用下面的符号：只要在加引号的文本中发现反斜杠（\），就表示其后的字符具有特殊含义，这称为转义字符（*escaping* the character）。以反斜杠开头的引号不会结束字符串，而是字符串的一部分。当```n```字符出现在一个反斜杠的后面，它被转译成一个换行符（newline）。相似地，在反斜杠后面的```t```代表一个制表符（tab）。

以下字符串：

```javascript
"This is the first line\nAnd this is the second"
```

它表示的真实文本是这个：

```
This is the first line
And this is the second
```

当然在某些情况下，你希望一个反斜杠就是反斜杠，而非一个特殊的代码。如果两个反斜杠挨在一起，那么它们会折叠起来，只有一个会被留在字符串中作为结果。“*A newline character is written like `"`\n`"`.*” 这串字符串用以下方式表达：

```javascript
"A newline character is written like \"\\n\"."
```

同样，字符串也要被建模为一系列的位才能在计算机中存在。JS实现它的方式是基于Unicode标准，这个标准几乎为我们所需要的每个字符都分配了一个数字，包括：希腊语（Greek），阿拉伯语（Arabic），日语（Japanese），亚美尼亚语（Armenian）等等。如此一来，每一个字符串都对应一个数字，一个字符串就可以用一系列的数字来描述了。

这就是JS所做的事情。但同时也出现了一个问题：JS中每个字符都用16位表示，这样它就有 2^16^ 种不同的字符了。而 Unicode 定义的字符远比它多，大概是它的两倍。因此有些字符，比如表情符号（emoji），就在JS字符串中占据两个“字符位置”（character positions）。我们会在第五章（[Chapter 5](https://eloquentjavascript.net/05_higher_order.html#code_units)）继续探讨。

字符串是不能被除、乘或者减的，但是可以用```+```这个运算符。它不是加法，但是它可以连接（*concatenates*）两个字符串。下一行将会产生字符串的这种连接：

```javascript
"con" + "cat" + "e" + "nate"
```

字符串的值有许多相关联的函数（方法），并且可以用来对它们执行其他的操作。更多的细节将会在第四章（[Chapter 4](https://eloquentjavascript.net/04_data.html#methods)）谈到。

字符串既可以用单引号书写，又可以用双引号书写，它们唯一的区别就是你需要用哪种类型的引号进行转义。反引号引起来的字符串，通常称为模板字面量（template literals），它的用处更大。除了能够跨行，还能嵌入其他值。

```javascript
`half of 100 is ${100 / 2}`
```

当你在一个模板字面量中写```${}```，它的结果将会被计算，转换成一个字符串，然后在那个位置上出现。这个例子就会产生 "*half of 100 is 50*"。

## 一元运算符 （Unary Operators）

并不是所有的运算符都是符号，有一些写起来像单词。```typeof```运算符就是一个例子，它会生成一个字符串的值，这个值就是你提供给它的值的类型。

```javascript
console.log(typeof 4.5)
// → number
console.log(typeof "x")
// → string
```

我们将会使用 console.log 来展示结果，更多的内容在下一章（[next chapter](https://eloquentjavascript.net/02_program_structure.html)）会提到。

其他的运算符需要两个值才能进行运算，而```typeof```只需要一个。使用两个值的运算符称为二元运算符（*binary* operators），只用一个值的称为一元运算符（*unary* operators）。减号运算符（minus operator）既可以用作二元运算符，也可以用作一元运算符。

```javascript
console.log(- (10 - 2))
// → -8
```

## 布尔值（Boolean Values）

有一个非常有用的值是用来区分两种可能性的，像是：yes and no or on and off。它就是JS中的布尔类型（*Boolean* type），它只有两个值，true 和 false。

## 比较 （Comparison）

这里有一个办法来产生布尔值：

```javascript
console.log(3 > 2)
// → true
console.log(3 < 2)
// → false
```

```>``` 和 ```<``` 符号分别代表传统意义上的“大于”和“小于”。它们是二元运算符，用它们就能产生一个布尔值，以此来指出在示例中它们是否为真。（译者说：即一个条件是否成立的意思。）

字符串也可以用同样的方式来比较。

```javascript
console.log("Aardvark" < "Zoroaster")
// → true
```

字符串的排序方式大致上是按字母顺序排列的，但并不是你真正希望看到的那样：大写字母总是“小于”小写字母，因此 "Z" < "a"，非字母的字符（!，-，等等）也被包含在那个序列中。在比较字符串的时候，JavaScript从左到右遍历字符，按照 Unicode 编码一个一个对比。

其他相似的运算符有：```>=```（大于或等于），```<=```（小于或等于），```==```（等于），```!=```（不等于）。

```javascript
console.log("Itchy" != "Scratchy")
// → true
console.log("Apple" == "Orange")
// → false
```

在JS中，只有一个值不等于它自己，那就是```NaN```（not a number）。

```javascript
console.log(NaN == NaN)
// → false
```

```NaN``` 被用来表示无意义的运算结果，同时它也不等于任何其他无意义的结果。

## 逻辑运算符 （Logical Operators）

有一些运算符可以应用到布尔值本身。JS 支持三种逻辑运算符：与，或，非。（*and*, *or*, and *not*）这些可以用来推理布尔值。

```&&```运算符表示逻辑与。它是一个二元运算符，只有在给定的两个值都为true时，其结果才为true。

```javascript
console.log(true && false)
// → false
console.log(true && true)
// → true
```

```||```运算符表示逻辑或。只要有一个值的结果是true，那么它的结果就是true。

```javascript
console.log(false || true)
// → true
console.log(false || false)
// → false
```

```!```运算符表示逻辑非。它是一元运算符，用来翻转给定的值，```!true```产生```false```，```!false```产生```true```。

当把这些布尔运算符和算术运算符以及其他运算符混在一起时，它就不是那么清晰明白了，这时就要加上小括号。实际上，你可以通过我们目前看到的运算符来解决，```||```的优先级最小，接下来是```&&```，然后是比较运算符（>，==，等等），然后是剩下的那些。在下面这个典型的表达式中，括号越少越好：

```javascript
1 + 1 == 2 && 10 * 10 > 50
```

最后一个我要提到的逻辑运算符不是一元的，也不是二元的，而是三元运算符，它需要三个值才能操作。它由一个问号（question）和一个冒号（colon）组成，就像这样：

```javascript
console.log(true ? 1 : 2);
// → 1
console.log(false ? 1 : 2);
// → 2
```

它被称为条件运算符（*conditional* operator 有时候也叫作三元运算符，因为它是语言中唯一的这样一个形式的运算符）。问号左边的值将会“挑出”另外两个值到底哪一个作为结果。如果它是 true，就选择中间的值，反之，选择右侧的值。

## 空值 （Empty Values）

有两个特殊的值：```null``` 和 ```undefined```，它们被用来表示一个有意义值的缺失（the absence of a *meaningful* value）。它们本身也是值，但是不带任何信息。

这门语言中的许多操作都不提供一个有意义的值（你之后就能遇到一些），而是简单地产生一个```undefined```，因为它们必须要留下一些值。

```undefined``` 和 ```null``` 之间的区别是JS设计中的意外，这在大多数情况下都没有关系。如果你某个地方必须关心这些值，我建议将它们视为可互换的。

##  类型的自动转换（Automatic Type Conversion）

在介绍部分，我提到JS会接受你给它的几乎所有程序，即使是做一个奇怪的事情的程序。以下表达式很好地证明了这一点：

```javascript
console.log(8 * null)
// → 0
console.log("5" - 1)
// → 4
console.log("5" + 1)
// → 51
console.log("five" * 2)
// → NaN
console.log(false == 0)
// → true
```

当一个运算符遇到“错误”的值，JS 会快速地以一种你不想要或者不期待的规则，去将不对的值转换为需要的值，这就是类型转换（*type coercion*）。第一个表达式的```null```会转换为 0，第二个表达式的字符串 "5" 会转换为数字 5（from string to number）。第三个表达式中的```+```会在数字相加之前尝试字符串的连接，所以 1 就被转换为 "1" （from number to string）。

当有些东西显然是没办法转换为一个数字的时候（such as `"five"` or `undefined`），你就会得到 ```NaN```的值。在 NaN 上进行进一步的算术运算会继续生成 NaN，因此如果你遇到了意料之外的值时，看看是不是类型转换导致的。

当比较两个值是否相等时，我们用```==```，结果显而易见：如果两个值一模一样，那么得到 true，NaN 不算。如果两个值不等，JS 就会使用一个更加复杂和令人困惑的规则去决定结果。大多数情况下，它仅仅会试着将其中一个值转换为另一个值的类型。但是，当运算符的任意一边出现 ```null``` 或 ```undefined``` 的时候，只有当双方均为 ```null``` 或 ```undefined``` 之一时，它才会产生 true。

```javascript
console.log(null == undefined);
// → true
console.log(null == 0);
// → false
```

这种表现非常有用。当你想要测试一个值是否有真正的值而不是```null```或者```undefined```的时候，你可以用 == （或者 !=）将它与 null 进行比较。

但是如果你想要测试某个东西是否指向精确的 false 值时，该怎么办？像 `0 == false` ，`""  == false` 这些表达式会自动类型转换成 true，当你不想要任何的类型转换时，有两个运算符可以用： `===` 和 `!==`。第一个用来测试一个值是否完全等于另一个值，第二个用来测试两个值是否完全不相等。（译者说：不仅比较大小，还比较类型。）因此，```"" === false``` 如我们希望的那样得到 false 。

为了避免出问题，我建议使用三等运算符来比较值。但是当你确定两边的值类型相同时，用 == 也没什么问题。

## 逻辑运算符的短路 （Short-circuiting Of Logical Operators）

逻辑运算符 `&&` 和 `||` 会以一种特殊的方式去处理不同类型的值。它们会将左边的值转换为布尔类型，以便决定要做什么，但根据运算符和转换的结果，它们将返回左边或者右边原来的那个值。

当左侧的值转换为 true，那么 `||` 运算符将会返回左侧的值，反之返回右侧的值。

```javascript
console.log(null || "user")
// → user
console.log("Agnes" || "user")
// → Agnes
```

我们可以使用这个设计功能作为返回一个默认值的途径。如果有一个值是空的，你就可以在这个空值的后面加上`||`，在`||`的后面写上你期望的替换值。如果一个初始值被转换为 false，那你就会得到那个替换值。用于将字符串和数字转换为布尔值的规则规定，0、NaN 和 空字符串（""）会转换为 false，而所有其他值都将转换为 true。因此， ```0 || -1``` 产生 -1 ，```"" || "!?"``` 产生 "!?"。

`&&` 的原理与之类似，但正好相反。当它左边的值转换为 false 时，它就会返回那个值，否则返回右侧的值。

这两个运算符的另一个非常重要的属性是，只在必要的时候才会对右侧的部分进行运算。```true || X``` 不管 X 是什么，就算它是一个做了非常糟糕事情的一段程序，结果也只会是 true ，X 是不会被计算的。`false && X` 也是一样，它的结果就是 false ，X 会被忽略。这称为短路评估（*short-circuit evaluation*）。

条件运算符的原理与之类似，在第二个和第三个值中，只计算选中的那个值。

## 总结（Summary）

在这一章节，我们看了四种JS的值类型（数据类型）：number、strings、Boolean 以及 undefined。

这样的值是通过输入它们的名称（true，null）或是值（13， "abc"）创建的，你可以用运算符去组合、转换值。我们看了用于算术运算的二元运算符（+`, `-`, `*`, `/`, and `%），字符串连接符（+），比较运算符（==`, `!=`, `===`, `!==`, `<`, `>`, `<=`, `>=），以及逻辑运算符（&&`, `||），还有几个一元运算符（- 让一个数字求反，! 对逻辑值求反，typeof 用来找到一个值的类型），还有一个三元运算符（?:），它根据第三个值从两个值中选择一个值。

这为你提供了足够的信息来把JavaScript作为一个袖珍计算器，但仅此而已。下一章将开始用这些表达式组成基本的程序。

**2021.4.14 Knight**